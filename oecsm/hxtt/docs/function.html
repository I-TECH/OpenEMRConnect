<html><head><TITLE>function.html - HXTT Access JDBC Drivers for Microsoft Access (MS Access) 95/97/2000/XP/2002/2003/2007/2010 v5.1</TITLE><meta name="keywords"  content="Access, JDBC, jdbc drivers, Java, database, HXTT"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body>
<p><font size="+1"><b>Chapter 7. Scalar Functions and Aggregate Functions</b></font></p>
<p><b>Index</b>: </p>
<ol>
  <li><a href="#mathematical ">Mathematical Functions</a></li>
  <li><a href="#trigonometric">Trigonometric  Functions</a></li>
  <li><a href="#string">String Functions</a></li>
  <li><a href="#date">Date/Time Functions</a></li>
  <li><a href="#boolean">Boolean Functions</a></li>
  <li><a href="#system">System Functions</a></li>
  <li><a href="#conversion">Conversion Functions</a></li>
  <li><a href="#security">Security Functions</a></li>
  <li><a href="#sequence">Sequence Functions</a></li>
  <li><a href="#regexp">Regular Expresson Functions</a></li>  
  <li><a href="#miscellaneous">Miscellaneous Functions</a></li>
  <li><a href="#aggregate">Aggregate Functions</a></li>
</ol>
<p><A name=mathematical>Mathematical Functions</a></p>
<ol>
  <ol>
    <li>ABS(x): the absolute value</li>
    <li>BITAND(x, y): returns the result of performing a bitwise AND on x and y.</li>
    <li>BIT_COUNT(x): returns the number of bits of x.</li>
    <li>CEIL(x), CEILING(x): the smallest integer that is not less than x</li>
    <li>DEGREES(x): converts radians to degrees</li>
    <li>EXP(x): exponential, e(2.718...) raised to the power of x</li>
    <li>FLOOR(x): the largest integer not greater than argument x</li>
    <li>INT(x) : truncates x to nearest integer</li>
    <li>LOG(x), LN(x): the natural logarithm</li>
    <li>LOG(b,x): returns the logarithm of X for an arbitary base B</li>
    <li> LOG10(x): the base 10 logarithm</li>
    <li>LOG2(X): the base 2 logarithm</li>
    <li>LN(x): the natural logarithm</li>
    <li>MOD(y, x): the remainder of y/x, you can use y%x too.</li>
    <li>PI(): pi constant, 3.14159265358979323846.</li>
    <li>POW(x, y), POWER(x, y): x raised to the power of y</li>
    <li>RADIANS(x): converts degrees to radians</li>
    <li>RAND([seed]): a random value between 0.0 and 1.0</li>
    <li>ROUND(x [,y]): rounds x to nearest integer without y, or round x to y
      digits after the decimal point.</li>
    <li>SIGN(x): returns -1 if x is smaller than 0, 0 if x==0 and 1 if x is bigger
      than 0.</li>
    <li>SQRT(x): the square root</li>
    <li>TRUNC(x[,y]), TRUNCATE(x[,y]): truncates x to nearest integer without
      y, truncates x to y digits after the decimal point</li>
  </ol>
</ol>
<p><A name=trigonometric>Trigonometric Functions</a></p>
<ol>
  <ol>
    <li>ACOS(x): the inverse cosine of an angle</li>
    <li>ASIN(x): the inverse sine of an angle</li>
    <li>ATAN(x),ATN(x): the inverse tangent of an angle</li>
    <li>ATAN2(x, y): the inverse tangent of x/y</li>
    <li>COS(x): the cosine of an angle</li>
    <li>COT(x): the cotangent of an angle</li>
    <li>SIN(x): the sine of an angle</li>
    <li>TAN(x): the tangent of an angle</li>
  </ol>
</ol>
<p><A name=string>String Functions</a></p>
<ol>
  <ol>
    <li>ALLTRIM(string1): removes all leading and trailing blanks in string1</li>
    <li>ASC(string1), ASCII(string1): the ASCII code of the leftmost character of the argument</li>
    <li>AT(cSearchExpression, cExpressionSearched [, nOccurrence]): returns the
      beginning numeric position of the first occurrence of a character expression
      or memo field within another character expression or memo field, counting
      from the leftmost character. If the character expression isn't found, AT(
      ) returns 0.</li>
    <li>ATC(cSearchExpression, cExpressionSearched [, nOccurrence]): returns the
      beginning numeric position of the first occurrence of a character expression
      or memo field within another character expression or memo field, counting
      from the leftmost character. If the character expression isn't found, AT(
      ) returns 0. It is case insensitive.</li>
    <li>BIN(number1): returns a string representation of the binary value of number1, where number1 is a integer(TINYINT, SMALLINT, INT, or BIGINT) number. Returns NULL if N is NULL.<br>
    </li>
    <li>BIT_LENGTH(string1): the length of the string str in bits<br>
    </li>
    <li>CHAR_LENGTH(string1), CHARACTER_LENGTH(string1): the number of characters in string1<br>
    </li>
    <li>CHAR(integer), CHR(integer): a character with the given ASCII code</li>
    <li>CHAR(integer1,...): interprets the arguments as integers and returns a string consisting of the characters given by the unicode values of those integers. NULL values are skipped.
</li>
    <li>CHRTRAN(cSearchedExpression, cSearchExpression, cReplacementExpression):
      Replaces each character in a character expression that matches a character
      in a second character expression with the corresponding character in a third
      character expression. CHRTRAN( ) translates the character expression cSearchedExpression
      using the translation expressions cSearchExpression and cReplacementExpression
      and returns the resulting character string. If a character in cSearchExpression
      is found in cSearchedExpression, the character in cSearchedExpression is
      replaced by a character from cReplacementExpression that's in the same position
      in cReplacementExpression as the respective character in cSearchExpression.
      If cReplacementExpression has fewer characters than cSearchExpression, the
      additional characters in cSearchExpression are deleted from cSearchedExpression.
      If cReplacementExpression has more characters than cSearchExpression, the
      additional characters in cReplacementExpression are ignored.<br>
    </li>
    <li>CONCAT(string1, string2): string concatenation, you can use string1+string2
      too.</li>
    <li>CONCAT(string1, string2,...): returns the string that results from concatenating the arguments. NULL values are skipped.</li>
    <li>CONCAT_WS(separator,string1, string2,...): returns the string that results from concatenating the arguments. The first argument is the separator for the rest of the arguments. The separator is added between the strings to be concatenated. If the separator is NULL, the result is NULL. The function skips any NULL values after the separator argument.</li>
    <li>CONV(number1,base):  returns a string representation of the first argument in the
      radix specified by the second argument. The minimum base is 2 and the maximum base is 36.</li>
    <li>DIFFERENCE(string1, string2): the difference between the sound of string1
      and string2</li>
    <li>HEX(number1): returns a string representation of the hexadecimal value of number1, where number1 is a integer(TINYINT, SMALLINT, INT, or BIGINT) number. Returns NULL if N is NULL.<br>
    </li>
    <li>INITCAP(string1): converts first letter of each word (whitespace-separated)
      to upper case</li>
    <li>INSERT(string1, start1, length1, string2): a string where length1 number
      of characters beginning at start1 has been replaced by string2</li>
    <li>INSTR(string1, string2 [,start1]): the first index (&gt;0:left location,
      0:not found) where string2 is found in string1, starting at start1</li>
    <li>INSTR(start1, string1, string2): (Compatible purpose) the first index (&gt;0:left location,
      0:not found) where string2 is found in string1, starting at start1.</li>
    <li>LCASE(string1): converts string1 to lower case</li>
    <li>LEFT(string1, count1): the leftmost count1 of characters of string1</li>
    <li>LENGTH(string1), LEN(string1): the number of characters in string1</li>
    <li>LOCATE(string1, string2 [,start1]): the first index (&gt;0:left location,
      0:not found) where string1 is found in string2, starting at start1</li>
    <li>LOWER(string1): converts string1 to lower case</li>
    <li>LPAD(string1, length1 [, cPadCharacter]): returns a string from an expression,
      padded with character(a space by default) to a specified length on the left.
      If the string is already longer than length then it is truncated (on the
      right). </li>
    <li>LTRIM(string1): removes all leading blanks in string1</li>
    <li>MID(string1 FROM start1 [FOR length1]), MID(string1, start1
      [,length1]): extracts the substring starting at start1 with length length1. MID is a synonym for SUBSTRING.</li>
    <li>OCT(number1): returns a string representation of the octal value of number1, where number1 is a integer(TINYINT, SMALLINT, INT, or BIGINT) number. Returns NULL if N is NULL.<br>
    </li>
    <li>OCTET_LENGTH(string1): the number of octets (8-bit bytes) needed to represent the string1.</li>
    <li>PADC(string1, length1 [, cPadCharacter]): returns a string from an expression,
      padded with character(a space by default) to a specified length on both
      sides. If the string is already longer than length then it is truncated
      (on the right). <br>
    </li>
    <li>PADL(string1, length1 [, cPadCharacter]): returns a string from an expression,
      padded with character(a space by default) to a specified length on the left.
      If the string is already longer than length then it is truncated (on the
      right). </li>
    <li>PADR(string1, length1 [, cPadCharacter]): returns a string from an expression,
      padded with character(a space by default) to a specified length on the right.
      If the string is already longer than length then it is truncated (on the
      right). </li>
    <li>POSITION( s1 IN s2), POSITION(substr,str): location of specified substring</li>
    <li>PROPER(STRING1) : returns from a character expression a string capitalized as appropriate for proper names.</li>
    <li>REPEAT(string1, count1): repeats string1 count1 times</li>
    <li>REPLICATE(string1, count1): same as REPEAT(string1,count1)</li>
    <li>REPLACE(string1, string2, string3): replaces all occurrences in string1
      of substring string2 with substring string3.</li>
    <li>RIGHT(string1, count1): the rightmost count1 of characters of string1</li>
    <li>RPAD(string1, length1 [, cPadCharacter]): returns a string from an expression,
      padded with character(a space by default) to a specified length on the right.
      If the string is already longer than length then it is truncated (on the
      right). </li>
    <li>RTRIM(string1): removes all trailing blanks in string1</li>
    <li>SOUNDEX(string1): a four character code representing the sound of string1</li>
    <li>SPACE(nSpaces): returns a character string composed of a specified number
      of spaces.</li>
		<li>STRCAT(string1, string2): string concatenation, you can use string1+string2 too,same as CONCAT.</li>
    <li>STRCAT(string1, string2,...): returns the string that results from concatenating the arguments, NULL values are skipped,same as CONCAT.</li>

    <li>STRCMP(expr1,expr2): returns 0 if the strings are the same, -1 if the
      first argument is smaller than the second, and 1 otherwise.</li>
    <li>STRCONV(expr1 [, charsetName]): returns a string by decoding the specified array of bytes using the specified charset. Cp895(Czech MS - DOS 895), Cp620(Polish MS - DOS 620) and Mazovia are extra supported although JVM doesn't support those. The omitted charsetName is 'ISO8859_1'.</li>
    <li>STRTRAN(cSearched, cSearchFor [, cReplacement][, nStartOccurrence] [,
      nNumberOfOccurrences]): searches a character expression or memo field for
      occurrences of a second character expression or memo field, and then replaces
      each occurrence with a third character expression or memo field.<br>
    </li>
    <li>STUFF(cExpression, nStartReplacement, nCharactersReplaced, cReplacement):
      returns a string created by replacing a specified number of characters in
      a character expression with another character expression. cExpression specifies
      the string expression in which the replacement occurs. nStartReplacement
      specifies the position in cExpression where the replacement begins. nCharactersReplaced
      specifies the number of characters to be replaced. If nCharactersReplaced
      is 0, the replacement string cReplacement is inserted into cExpression.
      cReplacement specifies the replacement string expression. If cReplacement
      is the empty string, the number of characters specified by nCharactersReplaced
      are removed from cExpression. <br>
    </li>
    <li>SUBSTR(string1, start1 [,length1]): extracts the substring starting at
      start1 with length length1</li>
    <li>SUBSTRING(string1 FROM start1 [FOR length1]), SUBSTRING(string1, start1
      [,length1]): extracts the substring starting at start1 with length length1</li>
    <li>TRANSLATE(string1, string2, string3): any character in string1 that matches
      a character in the string2 is replaced by the corresponding character in
      the string3.</li>
    <li>TRIM([[BOTH | LEADING | TRAILING] [removedstring1] FROM] string1): remove
      the removedstring1 (a space by default) from the start/end/both ends of
      the string1. </li>
    <li>UCASE(string1): converts string1 to upper case</li>
    <li>UPPER(string1): converts string1 to upper case</li>
    <li>CHARMIRR(string1 [,lDontMirrorSpaces]): mirrors string1 at character level.
      string1 is the string that should be mirrored. If lDontMirrorSpaces equal
      to true, spaces at the end of string1 will not be mirrored but kept at the
      end. lDontMirrorSpaces's default value is false, which means to mirror the
      whole string.</li>
    <li>REVERSE(string1[,lDontMirrorSpaces]): mirrors string1 at byte level.</li>
  </ol>
</ol>
<p><A name=date>Date/Time Functions</a></p>
<ol>
  <ol>
    <li>ADDTIME(expr,expr2): adds expr2 to expr and returns the result. expr is
      a date or timestamp expression, and expr2 is a time expression. </li>
    <li>CDOW(date) Returns the day-of-the-week(Sunday,Monday, Tuesday, Wednesday, Thursday, Friday,Saturday) from a given date,</li>
    <li>CMONTH(date) the name of the month </li>
    <li>CURDATE(): the current date</li>
    <li>CURTIME(): the current time</li>
    <li>DATE(): the current date</li>
    <li>DATE(expr): extracts the date part of the date or timestamp expression
      expr.</li>
    <li>DATETIME(): the current timestamp</li>
    <li>DATESERIAL(year,month,day): returns a date value representing a specified year, month, and day.</li>
    <li>DATE_ADD(date,INTERVAL expr type), DATE_SUB(date,INTERVAL expr type),
      ADDDATE(date,INTERVAL expr type), SUBDATE(date,INTERVAL expr type).  For instance, SELECT DATE_ADD(date1,INTERVAL hour(now())+1 HOUR), adddate(date1,interval 3 hour) FROM test;
<BR>
      <TABLE border=1>
        <TBODY>
        <TR>
          <TD width="143">type Value</TD>
          <TD width="225">Expected expr Format</TD>
        </TR>
        <TR>
          <TD width="143">MICROSECOND[S]</TD>
          <TD width="225">MICROSECONDS</TD>
        </TR>
        <TR>
          <TD width="143">MILLISECOND[S]</TD>
          <TD width="225">MILLISECONDS</TD>
        </TR>
        <TR>
          <TD width="143">SECOND</TD>
          <TD width="225">SECONDS</TD>
        </TR>
        <TR>
          <TD width="143">MINUTE</TD>
          <TD width="225">MINUTES</TD>
        </TR>
        <TR>
          <TD width="143">HOUR</TD>
          <TD width="225">HOURS</TD>
        </TR>
        <TR>
          <TD width="143">DAY</TD>
          <TD width="225">DAYS</TD>
        </TR>
        <TR>
          <TD width="143">WEEK</TD>
          <TD width="225">WEEKS</TD>
        </TR>
        <TR>
          <TD width="143">MONTH</TD>
          <TD width="225">MONTHS</TD>
        </TR>
        <TR>
          <TD width="143">QUARTER</TD>
          <TD width="225">QUARTERS</TD>
        </TR>
        <TR>
          <TD width="143">YEAR</TD>
          <TD width="225">YEARS</TD>
        </TR>
        <tr>
          <td width="143">DECADE</td>
          <td width="225">DECADES</td>
        </tr>
        <tr>
          <td width="143">CENTURY</td>
          <td width="225">CENTURYS</td>
        </tr>
        <tr>
          <td width="143">MILLENNIUM</td>
          <td width="225">MILLENNIUMS</td>
        </tr>
        <TR>
          <TD width="143">SECOND_MICROSECOND</TD>
          <TD width="225">'SECONDS.MICROSECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">MINUTE_MICROSECOND</TD>
          <TD width="225">'MINUTES.MICROSECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">MINUTE_SECOND</TD>
          <TD width="225">'MINUTES:SECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">HOUR_MICROSECOND</TD>
          <TD width="225">'HOURS.MICROSECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">HOUR_SECOND</TD>
          <TD width="225">'HOURS:MINUTES:SECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">HOUR_MINUTE</TD>
          <TD width="225">'HOURS:MINUTES'</TD>
        </TR>
        <TR>
          <TD width="143">DAY_MICROSECOND</TD>
          <TD width="225">'DAYS.MICROSECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">DAY_SECOND</TD>
          <TD width="225">'DAYS HOURS:MINUTES:SECONDS'</TD>
        </TR>
        <TR>
          <TD width="143">DAY_MINUTE</TD>
          <TD width="225">'DAYS HOURS:MINUTES'</TD>
        </TR>
        <TR>
          <TD width="143">DAY_HOUR</TD>
          <TD width="225">'DAYS HOURS'</TD>
        </TR>
        <TR>
          <TD width="143">YEAR_MONTH</TD>
          <TD width="225">'YEARS-MONTHS'</TD>
        </TR>
        </TBODY>
      </TABLE>
    </li>
    <li>DATEDIFF(expr,expr2): returns the number of days between the start date
      expr and the end date expr2. expr and expr2 are date or date-and-time expressions.
      Only the date parts of the values are used in the calculation. </li>
    <li>DATEADD(INTERVAL, expr, date), DATEDIFF (INTERVAL, date1, date2),    DATEPART (INTERVAL, date)
 For instance, SELECT DateAdd('m', 3, date1) FROM test;
<BR>	

      <TABLE border=1>
        <TBODY>
        <TR>
          <TD width="143">INTERVAL Value</TD>
          <TD width="225">Expected expr Format</TD>
        </TR>
        <TR>
          <TD width="143">yyyy</TD>
          <TD width="225">Year</TD>
        </TR>
        <TR>
          <TD width="143">q</TD>
          <TD width="225">Quarter</TD>
        </TR>
        <TR>
          <TD width="143">m</TD>
          <TD width="225">Month</TD>
        </TR>
        <TR>
          <TD width="143">y</TD>
          <TD width="225">Day of the year</TD>
        </TR>
        <TR>
          <TD width="143">d</TD>
          <TD width="225">Day</TD>
        </TR>
        <TR>
          <TD width="143">w</TD>
          <TD width="225">Weekday</TD>
        </TR>
        <TR>
          <TD width="143">ww</TD>
          <TD width="225">Week</TD>
        </TR>
        <TR>
          <TD width="143">h</TD>
          <TD width="225">Hour</TD>
        </TR>
        <TR>
          <TD width="143">n</TD>
          <TD width="225">Minute</TD>
        </TR>
        <TR>
          <TD width="143">s</TD>
          <TD width="225">Second</TD>
        </TR>	 	 	
        </TBODY>
      </TABLE>
    </li>

    <li>DAY(date1), DAYOFMONTH(date1): the day of the month (1-31)</li>
    <li>DAYNAME(date1): the name of the day<br>
    </li>
    <li> DAYOFWEEK(date1): the day of the week (1 means Sunday)<br>
    </li>
    <li> DAYOFYEAR(date1): the day of the year (1-366)</li>
    <li>EXTRACT(type FROM expr): extracts parts from the date.<br>
      <table border=1 width="509">
        <tbody>
        <tr>
          <td width="128">type Value</td>
          <td width="365">Expected Result</td>
        </tr>
        <tr>
          <td width="128">MICROSECOND[S]</td>
          <td width="365">MILLISECOND*1000</td>
        </tr>
        <tr>
          <td width="128">MILLISECOND[S]</td>
          <td width="365">indicats the millisecond within the second. </td>
        </tr>
        <tr>
          <td width="128">SECOND</td>
          <td width="365">indicats the second within the minute</td>
        </tr>
        <tr>
          <td width="128">MINUTE</td>
          <td width="365">MINUTES</td>
        </tr>
        <tr>
          <td width="128">HOUR</td>
          <td width="365">HOURS</td>
        </tr>
        <tr>
          <td width="128">DAY</td>
          <td width="365">DAYS</td>
        </tr>
        <tr>
          <td width="128">MONTH</td>
          <td width="365">MONTHS</td>
        </tr>
        <tr>
          <td width="128">QUARTER</td>
          <td width="365">QUARTERS</td>
        </tr>
        <tr>
          <td width="128">YEAR</td>
          <td width="365">YEARS</td>
        </tr>
        <tr>
          <td width="128">DECADE</td>
          <td width="365">DECADES</td>
        </tr>
        <tr>
          <td width="128">CENTURY</td>
          <td width="365">CENTURYS</td>
        </tr>
        <tr>
          <td width="128">MILLENNIUM</td>
          <td width="365">MILLENNIUMS</td>
        </tr>
        <tr>
          <td width="128">DOW</td>
          <td width="365">indicates the day of the week, SUNDAY, MONDAY, TUESDAY,
            WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY(1~7).</td>
        </tr>
        <tr>
          <td width="128">DOY</td>
          <td width="365">indicates the day number within the year. The first
            day of the year has value 1. </td>
        </tr>
        <tr>
          <td width="128">WEEK,WOM</td>
          <td width="365">indicats the ordinal number of the day of the week within
            the current month.</td>
        </tr>
        <tr>
          <td width="128">WOY</td>
          <td width="365">indicats the ordinal number of the day of the week within
            the current year.</td>
        </tr>
        <tr>
          <td width="128">EPOCH</td>
          <td width="365">the current time as UTC milliseconds from the epoch(1970-01-01
            00:00:00).</td>
        </tr>
        </tbody>
      </table>
    </li>
    <li>DOW(date1) get the day of the week, SUNDAY, MONDAY, TUESDAY,
            WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY(1~7) </li>
    <li>FROM_DAYS(expr1): given a day number expr1, returns a DATE value.</li>
    <li>GOMONTH(expr1,numMonths) : give a date,return the date before or after a number months</li>
    <li> HOUR(time1): the hour (0-23)</li>
    <li>LAST_DAY(date1): takes a date or timestamp value and returns the corresponding
      date for the last day of the month.</li>
    <li>MINUTE(time1): the minute (0-59)</li>
    <li>MILLISECOND(time1): the milliseconds from the time or timestamp expression
      time1.</li>
    <li>MICROSECOND(time1): the microseconds from the time or timestamp expression
      time1. <br>
    </li>
    <li>MONTH(time1): the month (1-12)<br>
    </li>
    <li>MONTHNAME(date1): the name of the month</li>
    <li>NOW(): the current date and time as a timestamp</li>
    <li>QUARTER(date1): the quarter (1-4)<br>
    </li>
    <li>SECOND(time1): the second (0-59)</li>
    <li>SEC(time1) (Compatible purpose): the second (0-59)</li>
    <li>SUBTIME(expr,expr2): subtracts expr2 from expr and returns the result.
      expr is a date or timestamp expression, and expr2 is a time expression.</li>
    <li>SYSDATE(): the current date and time as a timestamp. Asynonym for NOW().
      <br>
    </li>
    <li>TIME(): returns the current system time in 24-hour, eight-character string
      (hh:mm:ss) format.</li>
    <li>TIME(expr): extracts the time part of the time or timestamp expression
      expr.</li>
    <li>TIMEDIFF(expr,expr2) returns the time between the start time expr and
      the end time expr2. Only the time parts of the values are used in the calculation.</li>
    <li>TIMESERIAL(hour,minute,second): returns a Time value representing a specified hour, minute, and second.</li>
    <li>TIMESTAMP(expr): returns the date or timestamp expression expr as a timestamp
      value.</li>
    <li>TIMESTAMPADD(interval, count, timestamp1): adds the integer expression
      count to the date or timestamp expression timestamp1. interval can be SQL_TSI_FRAC_SECOND,
      SQL_TSI_SECOND, SQL_TSI_MINUTE, SQL_TSI_HOUR, SQL_TSI_DAY, SQL_TSI_WEEK,
      SQL_TSI_MONTH, SQL_TSI_QUARTER, SQL_TSI_YEAR, FRAC_SECOND, SECOND, MINUTE,
      HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.</li>
    <li>TIMESTAMPDIFF(interval, timestamp1, timpestamp2): returns the integer
      difference between the date or timestamp expressions timestamp1 and timpestamp2
      (timpestamp2-timestamp1). interval can be SQL_TSI_FRAC_SECOND, SQL_TSI_SECOND,
      SQL_TSI_MINUTE, SQL_TSI_HOUR, SQL_TSI_DAY, SQL_TSI_WEEK, SQL_TSI_MONTH,
      SQL_TSI_QUARTER, SQL_TSI_YEAR, FRAC_SECOND, SECOND, MINUTE, HOUR, DAY, WEEK,
      MONTH, QUARTER, or YEAR.</li>
    <li>TO_DAYS(date1): given a date date1, returns a day number.</li>
    <li>WEEK(date1), WEEKOFYEAR(date1): the week of this year (1-53) <br>
    </li>
    <li>YEAR(date1): the year</li>
  </ol>
</ol>
<p><A name=boolean>Boolean Functions</a></p>
<ol>
  <ol>
    <li>BETWEEN(expression1,expression2,expression3) :
        determines whether the value of an expression1 lies between the expression2 and expression3,
        return true or false.
    <li>EMPTY(expression): determines whether an expression evaluates to empty
      or null. The expression you include can be a string, numeric, date, or logical
      expression. EMPTY() returns true, when a string is empty string, spaces,
      tabs, carriage returns, linefeeds, or any combination of these, numeric
      value equals to 0, and logical expression is false.</li>
    <li>ISBLANK(expression): determines whether an expression evaluates to empty
      or null. The expression you include can be a string, numeric, date, or logical
      expression. ISBLANK() returns true, when a string is empty string or spaces,
      numeric value equals to null, and logical expression is null.</li>
   <li>ISALPHA(expression): determines whether the leftmost character in a character expression is alphabetic.</li>
   <li>ISDATE(expression): determines whether an expression can be converted to a date value.</li>
   <li>ISDIGIT(expression): determines whether the leftmost character of the specified character expression is a digit (0 through 9).</li>
   <li>ISDIGITS(expression): determines whether a string contains only digits(0 through 9).</li>
    <li>ISNULL(expression): determines whether an expression evaluates to null.
      The expression you include can be a string, numeric, date, or logical expression.
      If expression is NULL, ISNULL() returns true, otherwise it returns false.<br>
    </li>
   <li>ISNUMERIC(expression): determines whether an expression can be converted to a number value.</li>
  </ol>
</ol>
<p><A name=system>System Functions</a></p>
<ol>
  <ol>
    <li>DATABASE(): the name of the database of this connection<br>
    </li>
    <li>USER(): the user name of this connection<br>
    </li>
    <li>DELETED([cTableAlias | nWorkArea]): returns a logical value that indicates
      whether the current record is marked for deletion. </li>
    <li>RECCOUNT([cTableAlias | nWorkArea]): returns the number of records, which
      includes all deleted records. </li>
    <li>RECNO([cTableAlias | nWorkArea]): returns the current record number in
      the current or specified table. nWorkArea specifies the work area number
      for a table open in another work area. cTableAlias specifies the table alias
      for a table open in another work area.</li>
    <li>ROWLOCKED([cTableAlias | nWorkArea]): indicates whether the current row
      has been locked by process or application.</li>
    <li>TABLELOCKED(cTableName): indicates whether a table has been locked by process or application. For instance, select tablelocked('test').</li>
    <li>CURRVAL(cTableName, cColumnName): returns the last generated IDENTITY(auto_increment) value for a particuar table. If that table hasn't IDENTITY(auto_increment) column, it will return silently null value. Only when there's more than one auto_increment column in a table, it will check cColumnName's validity.</li>

  </ol>
</ol>
<p><A name=conversion>Conversion Functions</a></p>
<ol>
  <ol>
    <li>CAST(expression AS  data_type): converts value1 to another data type  data_type.
       data_type may be SQL_BIGINT(Types.BIGINT), SQL_BINARY(Types.BINARY), SQL_BIT(Types.BIT),
      SQL_CHAR(Types.CHAR), SQL_DATE(Types.DATE), SQL_DECIMAL(Types.DECIMAL),
      SQL_DOUBLE(Types.DOUBLE), SQL_FLOAT(Types.FLOAT), SQL_INTEGER(Types.INTEGER),
      SQL_LONGVARBINARY(Types.LONGVARBINARY), SQL_LONGVARCHAR(Types.LONGVARCHAR),
      SQL_REAL(Types.REAL), SQL_SMALLINT(Types.SMALLINT), SQL_TIME(Types.TIME),
      SQL_TIMESTAMP(Types.TIMESTAMP), SQL_TINYINT(Types.TINYINT), SQL_VARBINARY(Types.VARBINARY),
      SQL_VARCHAR(Types.VARCHAR), BIGINT(Types.BIGINT), BINARY(Types.BINARY),
      BIT(Types.BIT), CHAR(Types.CHAR), DATE(Types.DATE), DECIMAL(Types.DECIMAL),
      DOUBLE(Types.DOUBLE), FLOAT(Types.FLOAT), INTEGER(Types.INTEGER), INT(Types.INTEGER), LONGVARBINARY(Types.LONGVARBINARY),
      LONGVARCHAR(Types.LONGVARCHAR), NUMERIC (Types.NUMERIC), REAL(Types.REAL), SMALLINT(Types.SMALLINT),
      TIME(Types.TIME), TIMESTAMP(Types.TIMESTAMP), TINYINT(Types.TINYINT), VARBINARY(Types.VARBINARY),
      and VARCHAR(Types.VARCHAR). For instance, cast('456' AS SQL_INTEGER),cast('123.456' AS DECIMAL(12,5)), and cast('2004-12-23' as sql_date).<br>
    </li>
    <li>CONVERT(value1, SQLtype1): converts value1 to another data type SQLtype1.
      SQLtype1 may be SQL_BIGINT(Types.BIGINT), SQL_BINARY(Types.BINARY), SQL_BIT(Types.BIT),
      SQL_CHAR(Types.CHAR), SQL_DATE(Types.DATE), SQL_DECIMAL(Types.DECIMAL),
      SQL_DOUBLE(Types.DOUBLE), SQL_FLOAT(Types.FLOAT), SQL_INTEGER(Types.INTEGER), INT(Types.INTEGER),
      SQL_LONGVARBINARY(Types.LONGVARBINARY), SQL_LONGVARCHAR(Types.LONGVARCHAR),
      SQL_REAL(Types.REAL), SQL_SMALLINT(Types.SMALLINT), SQL_TIME(Types.TIME),
      SQL_TIMESTAMP(Types.TIMESTAMP), SQL_TINYINT(Types.TINYINT), SQL_VARBINARY(Types.VARBINARY),
      and SQL_VARCHAR(Types.VARCHAR). value1 may be any complicated expression.
      For instance, CONVERT("123",SQL_INTEGER).</li>
    <li>CBOOL(expression): returns a Boolean value from an expression.<br>
    </li>
    <li>CBYTE(expression): returns a Byte value from an expression.<br>
    </li>
    <li>CCUR(expression): returns a Currency value with four decimal digits of precision to the right of the decimal from an expression.<br>
    </li>
    <li>CDATE(expression,pattern): returns a Date value according a pattern from an expression. For instance, CDATE('21111947','ddMMyyyy').<br>
    </li>
    <li>CDBL(expression): returns a Double value from an expression.<br>
    </li>
    <li>CINT(expression): returns an Integer  value from an expression.<br>
    </li>
    <li>CLNG(expression): returns a Long value from an expression.<br>
    </li>
    <li>CSNG(expression): returns a Float value from an expression.<br>
    </li>
    <li>CSTR(expression): returns a String value from an expression.<br>
    </li>
    <li>CTOD(cExpression): converts a string expression to a date expression.<br>
    </li>
    <li>CTOT(cExpression): returns a timestamp value from a string expression.<br>
    </li>
    <li> DTOC(date1 | timestamp1[, 1]): returns a string from a date or timestamp expression.</li>
    <li>DTOT(dDateExpression): returns a timestamp value from a date expression.<br>
    </li>
    <li>DTOS(date1 | timestamp1): returns a string in a yyyymmdd format from a
      specified date or timestamp expression.</li>
    <li>DTOS(date1 | timestamp1,pattern): returns a string according to a pattern format from a
      specified date or timestamp expression.</li>
    <li>TTOC(tExpression [, 1 | 2]): converts a timestamp expression to a string
      value of a specified format.</li>
    <li>TTOD(tExpression): returns a date value from a timestamp expression.</li>
    <li>POSIXTOT(expression): returns a timestamp value from a POSIX timestamp value.</li>
    <li>TTOPOSIX(tExpression): converts a timestamp expression to a POSIX timestamp value.</li>
    <li>STR(nExpression [, nLength [, nDecimalPlaces]]): Returns the character
      equivalent of a specified numeric expression. nExpression specifies the
      numeric expression STR( ) evaluates. nLength specifies the length of the
      character string STR( ) returns. The length includes one character for the
      decimal point and one character for each digit to the right of the decimal
      point. nDecimalPlaces specifies the number of decimal places in the character
      string STR( ) returns. If you specify fewer decimal places than are in nExpression,
      the extra digits are truncated. STR( ) pads the character string it returns
      with leading spaces if you specify a length larger than the number of digits
      to the left of the decimal point. STR( ) returns a string of asterisks,
      indicating numeric overflow, if you specify a length less than the number
      of digits to the left of the decimal point. </li>
    <li>STRZERO(nExpression, nLength[, nDecimals]): convert a numeric expression to a string padded with leading zeros.</li>
    <li>VAL(string1): returns a numeric value from a string1 composed of numbers.</li>
    <li>COLLATE(string1[,collation]): For multilingual sort in ORDER BY clause.
      Now collation can be 'DUTCH', 'GERMAN', 'ICELAND', 'SPANISH', 'RUSSIAN',
      'CZECH', 'GREEK', 'SLOVAK', 'POLISH', 'TURKISH', 'HUNGARY', CP850, CP852, CP866, CROATIAN, HEBREW, SWEDISH, and 'MAZOVIA'. Without collation parameter, COLLATE function will
      try to utilize charSet property in Connection properties.</li>
    <li>PasToJava(str): get a Java string from a Pascal-style string</li>
    <li>JavaToPas(str): get a Pascal-style string from a Java string</li>
    <li>PasToJava(str): get a null-terminated string from a Pascal-style string</li>
    <li>CToPas(str): get a Pascal-style string from a null-terminated string</li>
    <li>CToJava(str): get a Java string from a null-terminated string</li>
    <li>JavaToC(str): get a null-terminated from a Java string</li>
    <li>BToInt_LE(binary):  get int value from bytes with little-endian.</li>
    <li>BToInt_BE(binary):  get int value from bytes with big-endian.</li>
    <li>IntToB_LE(binary):  get bytes with little-endian from int value.</li>
    <li>IntToB_BE(binary):  get bytes with big-endian from int value.</li>
    <li>BToShort_LE(binary):  get short value from bytes with little-endian.</li>
    <li>BToShort_BE(binary):  get short value from bytes with big-endian.</li>
    <li>ShortToB_LE(binary):  get bytes with little-endian from short value.</li>
    <li>ShortToB_BE(binary):  get bytes with big-endian from short value.</li>
    <li>BToLong_LE(binary):  get long value from bytes with little-endian.</li>
    <li>BToLong_BE(binary):  get long value from bytes with big-endian.</li>
    <li>LongToB_LE(binary):  get bytes with little-endian from long value.</li>
    <li>LongToB_BE(binary):  get bytes with big-endian from long value.</li>

    <li>GetNumber(str[, defaultValue]):  return a number value(int, long, double) according to str. If failed to parse, return defaultValue(null is omitted value).</li>
    <li>GetInt(str[, defaultValue]):  return an int value according to str. If failed to parse, return defaultValue(null is omitted value).</li>
    <li>GetLong(str[, defaultValue]):  return a long value according to str. If failed to parse, return defaultValue(null is omitted value).</li>
    <li>GetDouble(str[, defaultValue]):  return a double value according to str. If failed to parse, return defaultValue(null is omitted value).</li>

    <li>FORMAT(expression , format): eturns a string containing an expression formatted according to instructions contained in a format expression. Now format supports only date/timestamp pattern.</li>

  </ol>
</ol>
<p><A name=security>Security Functions</a></p>
<ol>
  <ol>
    <li>COMPRESS(content) : Return a compressed byte[]</li>
    <li>UNCOMPRESS(compressedBytes) : Return an uncompressed byte[],please don't use it for non-compressed data</li>
    <li>ENCRYPT(content,cKey,cCryptMethod): Returns a crypted byte[]. cCryptMethod
      should be 'DES', 'TRIDES', or 'BLOWFISH' now. ENCRYPT function is used for
      VARBINARY column. Data Encryption Standard (DES) algorithm, adopted by the U.S. government in 1977, is a block cipher that transforms 64-bit data blocks under a 56-bit secret key, by means of permutation and substitution. It is officially described in FIPS PUB 46. The DES algorithm is used for many applications within the government and in the private sector. Triple-DES is an improvement over DES. It uses three DES keys k1, k2 and k3. A message is encrypted with k1 first, then decrypted with k2 and encrypted again with k3 (DESencryptiondecryptionencryption). This increases security as the key length effectively increases from 56 to 112 or 168 (two or three keys may be used in TriDES). The DES key size is 128 or 192 bit and block size 64 bit.</li>
    <li>DECRYPT(content,cKey,cCryptMethod): Returns a decrypted byte[]. cCryptMethod
      should be 'DES', 'TRIDES', or 'BLOWFISH' now.</li>
    <li>ENCODE(content): Encodes a BASE64 encoding string.
    <li>DECODE(content): Returns a byte[] from a BASE64 string.
    <li>ENCODE(content,cKey,cCryptMethod): Crypts and encodes content. cCryptMethod
      should be 'DES', 'TRIDES', or 'BLOWFISH'. ENCRYPT function is used for VARCHAR
      column. </li>
    <li>DECODE(content,cKey,cCryptMethod): Decodes and decrypts content. cCryptMethod
      should be 'DES', 'TRIDES', or 'BLOWFISH' now. </li>
    <li>MD5(string1): Calculates a MD5(Message-Digest Algorithm 5) checksum for the string1.</li>
    <li>SHA1(string1): Calculates a SHA-1(Secure Hash Algorithm 1) hash for the string1.</li>
    <li>Crypt3(word[, salt]): Returns a hashed string of 13 printable ASCII characters, with the first two characters represent the salt. It can be used to accept typed passwords from the user, or attempting to crack Unix passwords with a dictionary.</li>
  </ol>
</ol>
<p><A name=sequence>Sequence Functions</a></p>
<ol>
  <ol>
    <li>NEXTVAL(cSequenceName): advances sequence and returns new value.</li>
    <li>CURRVAL(cSequenceName): returns value most recently obtained with nextval.</li>
  </ol>
</ol>

<p><A name=regexp>Regular Expresson Functions</a></p>
<blockquote>
  <table border="1">
    <tr>
      <td>
        <div align="center"><b>Function</b></div>
      </td>
      <td>
        <div align="center"><b>Argument Type</b></div>
      </td>
      <td>
        <div align="center"><b>Return Type</b></div>
      </td>
      <td>
        <div align="center"><b>Description</b></div>
      </td>
    </tr>
   <tr>
      <td>
        <p>REGEXP_LIKE(expression,pattern[,match_parameter])</p>
      </td>
      <td>expression is a string expression that serves as the search value.<br>

pattern is the regular expression. For a listing of the operators you can specify in pattern, refer to java.util.regex.Matcher.Pattern.<br>

match_parameter is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_parameter:<br>

    'i' specifies case-insensitive matching.<br>

    'c' specifies case-sensitive matching.<br>

    'n' allows the period (.), which is the match-any-character wildcard character, to match the newline character. If you omit this parameter, then the period does not match the newline character.<br>

    'm' treats the source string as multiple lines. HXTT Access interprets ^ and $ as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then HXTT Access treats the source string as a single line.<br>

    'x' ignores whitespace characters. By default, whitespace characters match themselves.<br>

If you specify multiple contradictory values, then HXTT Access uses the last value. For example, if you specify 'ic', then HXTT Access uses case-sensitive matching. If you specify a character other than those shown above, then HXTT Access will ignore it.<br>

If you omit match_parameter, then:<br>

    The default case sensitivity is determined by the value of the caseInsensitive connection property.<br>

    A period (.) does not match the newline character.<br>

    The source string is treated as a single line.</td>
      <td>return true if it find one subsequence matches the pattern.</td>
      <td>REGEXP_LIKE is similar to the LIKE condition, except REGEXP_LIKE performs regular expression matching instead of the simple pattern matching performed by LIKE. This condition evaluates strings using characters as defined by the charSet connection property.</td>
    </tr>

  <tr>
      <td>
        <p>REGEXP_REPLACE(source_expression,pattern[, cReplacement[, nStartOccurrence [, nNumberOfOccurrences[,match_parameter]]]])</p>
      </td>
      <td>source_expression is a string expression that serves as the search value.<br>
pattern is the regular expression. IFor a listing of the operators you can specify in pattern, refer to java.util.regex.Matcher.Pattern.<br>

cReplacement may contain references to subsequences captured during the previous match: Each occurrence of $g will be replaced by the result of evaluating group(g). The first number after the $ is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals '0' through '9' are considered as potential components of the group reference. If the second group matched the string "foo", for example, then passing the replacement string "$2bar" would cause "foobar" to be appended to the string buffer. A dollar sign ($) may be included as a literal in the replacement string by preceding it with a backslash (\$).<br> 

nStartOccurrence is a positive integer indicating the character of source_expression where HXTT Access should begin the search. The default is 1, meaning that HXTT Accessbegins the search at the first character of source_expression.<br> 

nNumberOfOccurrences is a nonnegative integer indicating the occurrence of the replace operation:<br> 

    If you specify 0, then HXTT Access replaces all occurrences of the match.<br> 

    If you specify a positive integer n, then HXTT Access replaces the nth occurrence.<br> 

If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.
<br>

match_parameter is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_parameter:<br>

    'i' specifies case-insensitive matching.<br>

    'c' specifies case-sensitive matching.<br>

    'n' allows the period (.), which is the match-any-character wildcard character, to match the newline character. If you omit this parameter, then the period does not match the newline character.<br>

    'm' treats the source string as multiple lines. HXTT Access interprets ^ and $ as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then HXTT Access treats the source string as a single line.<br>

    'x' ignores whitespace characters. By default, whitespace characters match themselves.<br>

If you specify multiple contradictory values, then HXTT Access uses the last value. For example, if you specify 'ic', then HXTT Access uses case-sensitive matching. If you specify a character other than those shown above, then HXTT Access will ignore it.<br>

If you omit match_parameter, then:<br>

    The default case sensitivity is determined by the value of the caseInsensitive connection property.<br>

    A period (.) does not match the newline character.<br>

    The source string is treated as a single line.</td>
      <td>searches a character expression for occurrences of a pattern, and then replaces each occurrence with a third pattern expression.</td>
      <td>REGEXP_REPLACE extends the functionality of the STRTRAN function by letting you search a string for a regular expression pattern. By default, the function returns source_expression with every occurrence of the regular expression pattern replaced with replace_string. The string returned is in the same character set as source_expression.</td>
    </tr>


  <tr>
      <td>
        <p>REGEXP_INSTR(source_expression,pattern[, nStartOccurrence [, nNumberOfOccurrences[,return_option,[,match_parameter[,subexpr ]]]]])</p>
      </td>
      <td>source_expression is a string expression that serves as the search value.<br>
pattern is the regular expression. IFor a listing of the operators you can specify in pattern, refer to java.util.regex.Matcher.Pattern.<br>

nStartOccurrence is a positive integer indicating the character of source_expression where HXTT Access should begin the search. The default is 1, meaning that HXTT Accessbegins the search at the first character of source_expression.<br> 

nNumberOfOccurrences is a nonnegative integer indicating the occurrence of the replace operation:<br> 

    If you specify 0, then HXTT Access replaces all occurrences of the match.<br> 

    If you specify a positive integer n, then HXTT Access replaces the nth occurrence.<br> 

If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.
<br>
return_option lets you specify what HXTT Access should return in relation to the occurrence:<br>

    If you specify 0, then HXTT Access returns the position of the first character of the occurrence. This is the default.<br>

    If you specify 1, then HXTT Access returns the position of the character following the occurrence.<br>

match_parameter is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_parameter:<br>

    'i' specifies case-insensitive matching.<br>

    'c' specifies case-sensitive matching.<br>

    'n' allows the period (.), which is the match-any-character wildcard character, to match the newline character. If you omit this parameter, then the period does not match the newline character.<br>

    'm' treats the source string as multiple lines. HXTT Access interprets ^ and $ as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then HXTT Access treats the source string as a single line.<br>

    'x' ignores whitespace characters. By default, whitespace characters match themselves.<br>

If you specify multiple contradictory values, then HXTT Access uses the last value. For example, if you specify 'ic', then HXTT Access uses case-sensitive matching. If you specify a character other than those shown above, then HXTT Access will ignore it.<br>

If you omit match_parameter, then:<br>

    The default case sensitivity is determined by the value of the caseInsensitive connection property.<br>

    A period (.) does not match the newline character.<br>

    The source string is treated as a single line.
For a pattern with subexpressions, the subexpr is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression:<br>

0123(((abc)(de)f)ghi)45(678)<br>

This expression has five subexpressions in the following order: "abcdefghi" followed by "abcdef", "abc", "de" and "678".<br>

If subexpr is zero, then the position of the entire substring that matches the pattern is returned. If subexpr is greater than zero, then the position of the substring fragment that corresponds to subexpression number subexpr in the matched substring is returned. If pattern does not have at least subexpr subexpressions, the function returns zero. The default value for subexpr is zero.<br>
	</td>
      <td>returns the position of the first character of the occurrence or the character following the occurrence.</td>
      <td>REGEXP_INSTR extends the functionality of the INSTR function by letting you search a string for a regular expression pattern. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the return_option argument. If no match is found, then the function returns 0.</td>
    </tr>


  <tr>
      <td>
        <p>REGEXP_SUBSTR (source_expression,pattern[, nStartOccurrence [, nNumberOfOccurrences[,match_parameter[,subexpr ]]]]))</p>
      </td>
      <td>source_expression is a string expression that serves as the search value.<br>
pattern is the regular expression. IFor a listing of the operators you can specify in pattern, refer to java.util.regex.Matcher.Pattern.<br>
nStartOccurrence is a positive integer indicating the character of source_expression where HXTT Access should begin the search. The default is 1, meaning that HXTT Accessbegins the search at the first character of source_expression.<br> 

nNumberOfOccurrences is a nonnegative integer indicating the occurrence of the replace operation:<br> 

    If you specify 0, then HXTT Access replaces all occurrences of the match.<br> 

    If you specify a positive integer n, then HXTT Access replaces the nth occurrence.<br> 

If occurrence is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of pattern, and so forth. This behavior is different from the INSTR function, which begins its search for the second occurrence at the second character of the first occurrence.
<br>

match_parameter is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_parameter:<br>

    'i' specifies case-insensitive matching.<br>

    'c' specifies case-sensitive matching.<br>

    'n' allows the period (.), which is the match-any-character wildcard character, to match the newline character. If you omit this parameter, then the period does not match the newline character.<br>

    'm' treats the source string as multiple lines. HXTT Access interprets ^ and $ as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then HXTT Access treats the source string as a single line.<br>

    'x' ignores whitespace characters. By default, whitespace characters match themselves.<br>

If you specify multiple contradictory values, then HXTT Access uses the last value. For example, if you specify 'ic', then HXTT Access uses case-sensitive matching. If you specify a character other than those shown above, then HXTT Access will ignore it.<br>

If you omit match_parameter, then:<br>

    The default case sensitivity is determined by the value of the caseInsensitive connection property.<br>

    A period (.) does not match the newline character.<br>

    The source string is treated as a single line.<br>
For a pattern with subexpressions, the subexpr is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression:<br>

0123(((abc)(de)f)ghi)45(678)<br>

This expression has five subexpressions in the following order: "abcdefghi" followed by "abcdef", "abc", "de" and "678".<br>

If subexpr is zero, then the position of the entire substring that matches the pattern is returned. If subexpr is greater than zero, then the position of the substring fragment that corresponds to subexpression number subexpr in the matched substring is returned. If pattern does not have at least subexpr subexpressions, the function returns zero. The default value for subexpr is zero.<br>
	</td>

      <td>returns the substring of the occurrence.</td>
      <td>REGEXP_SUBSTR extends the functionality of the SUBSTR function by letting you search a string for a regular expression pattern. It returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. </td>
    </tr>


<tr>
      <td>
        <p>REGEXP_COUNT(source_expression,pattern[, nStartOccurrence[,match_parameter]])</p>
      </td>
      <td>source_expression is a string expression that serves as the search value.<br>
pattern is the regular expression. IFor a listing of the operators you can specify in pattern, refer to java.util.regex.Matcher.Pattern.<br>


nStartOccurrence is a positive integer indicating the character of source_expression where HXTT Access should begin the search. The default is 1, meaning that HXTT Accessbegins the search at the first character of source_expression.<br> 
match_parameter is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for match_parameter:<br>

    'i' specifies case-insensitive matching.<br>

    'c' specifies case-sensitive matching.<br>

    'n' allows the period (.), which is the match-any-character wildcard character, to match the newline character. If you omit this parameter, then the period does not match the newline character.<br>

    'm' treats the source string as multiple lines. HXTT Access interprets ^ and $ as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then HXTT Access treats the source string as a single line.<br>

    'x' ignores whitespace characters. By default, whitespace characters match themselves.<br>

If you specify multiple contradictory values, then HXTT Access uses the last value. For example, if you specify 'ic', then HXTT Access uses case-sensitive matching. If you specify a character other than those shown above, then HXTT Access will ignore it.<br>

If you omit match_parameter, then:<br>

    The default case sensitivity is determined by the value of the caseInsensitive connection property.<br>

    A period (.) does not match the newline character.<br>

    The source string is treated as a single line.</td>
      <td>returns the number of times a pattern occurs in a source string.</td>
      <td>REGEXP_COUNT returns the number of times a pattern occurs in a source string. It returns an integer indicating the number of occurrences of pattern. If no match is found, then the function returns 0.</td>
    </tr>

  </table>
</blockquote>



<p><A name=miscellaneous>Miscellaneous Functions</a></p>
<blockquote>
  <table border="1">
    <tr>
      <td>
        <div align="center"><b>Function</b></div>
      </td>
      <td>
        <div align="center"><b>Argument Type</b></div>
      </td>
      <td>
        <div align="center"><b>Return Type</b></div>
      </td>
      <td>
        <div align="center"><b>Description</b></div>
      </td>
    </tr>
   <tr>
      <td>
        <p>DECODE( expression , search , result [, search , result]... [, default] )</p>
      </td>
      <td>expression is the value to compare.

search is the value that is compared against expression.

result is the value returned, if expression is equal to search.

default is optional. If no matches are found, the decode will return default. If default is omitted, then the decode statement will return null (if no matches are found).</td>
      <td>same as argument type</td>
      <td>The decode function has the functionality of an IF-THEN-ELSE statement.</td>
    </tr>    <tr>
      <td>
        <p>GREATEST(expression1,expression2[,...])</p>
        <p>MAX(expression1,expression2[,...])</p>
      </td>
      <td>any numeric, string, date/time, or boolean type</td>
      <td>same as argument type</td>
      <td>maximum value of all expressions</td>
    </tr>
    <tr>
      <td>
        <p>LEAST(expression1,expression2[,...])</p>
        <p>MIN(expression1,expression2[,...])</p>
      </td>
      <td>any numeric, string, date/time, or boolean type</td>
      <td>same as argument type</td>
      <td>minimum value of all expressions</td>
    </tr>
    <tr>
      <td>
        <p>IF(lExpression, eExpression1, eExpression2)</p>
        <p>IIF(lExpression, eExpression1, eExpression2)</p>
        <p>&nbsp;</p>
      </td>
      <td>
        <p>lExpression specifies the logical expression that IF()/IIF( ) evaluates.</p>
      </td>
      <td>Returns one of two values depending on the value of a logical expression.<br>
      </td>
      <td>If lExpression evaluates to true , eExpression1 is returned. If lExpression
        evaluates to false, eExpression2 is returned.</td>
    </tr>
    <tr>
      <td>
        <p>NVL(expression, value)</p>
        <p>IFNULL(expression, value)</p>
      </td>
      <td>any numeric, string, date/time, or boolean type</td>
      <td>Returns one of two values depending on whether expression is null.</td>
      <td>If expression evaluates to null , value is returned. Otherwise, expression
        is returned.</td>
    </tr>
    <tr>
      <td>INLIST(eExpression1, eExpression2 [, eExpression3 ...])</td>
      <td>eExpression1 specifies the expression INLIST( ) searches for in the
        set of expressions. eExpression2 [, eExpression3 ...] specifies the set
        of expressions to search. You must include at least one expression (eExpression2),
        and can include up to 24 expressions (eExpression2, eExpression3, and
        so on).</td>
      <td>Determines whether an expression matches another expression in a set
        of expressions.</td>
      <td>All the expressions in the set of expressions must be of the same data
        type.<br>
      </td>
    </tr>
    <tr>
      <td>COALESCE(value [, ...])</td>
      <td>any numeric, string, date/time, or boolean type</td>
      <td>the type of the first of its arguments that is not null</td>
      <td>returns the first of its arguments that is not null</td>
    </tr>
     <tr>
      <td>ELT(numberExpression,value1Expression,[value2Expression,...]) </td>
      <td>numberExpression must be a integer type,value expression can be any type</td>
      <td>Returns value depending on the numberExpression,value1Expression,...valuexExpression</td>
      <td>Returns value1Expression if numberExpression = 1, value2Expression if numberExpression = 2, and so on.
          Returns NULL if N is less than 1 or greater than the number of arguments.</td>
    </tr>
    <tr>
      <td>INTERVAL(expression,expr1,expr2,...,exprn) </td>
      <td>any numeric, string, date/time, or boolean type</td>
      <td>integer value</td>
      <td>returns 0 if expression&lt; expr1, 1 if expression&lt; expr2 and so
        on or -1 if expressionN is NULL. If expression&gt;exprn, returns n.</td>
    </tr>
    <tr>
      <td>TRANSFER (expression, search_1, result_1)<br/>
          TRANSFER (expression, search_1, result_1, search_2, result_2)<br/>
					TRANSFER (expression, search_1, result_1, search_2, result_2, ...., search_n, result_n)<br/>
					TRANSFER (expression, search_1, result_1, default)<br/>
					TRANSFER (expression, search_1, result_1, search_2, result_2, default)<br/>
					TRANSFER (expression, search_1, result_1, search_2, result_2, ...., search_n, result_n, default)
			</td>
      <td>any numeric, string, date/time, or boolean type,or null</td>
      <td>Returns value depending on the expression,search_x,result_x and default</td>
      <td>TRANSFER compares expression to the search_x expressions and, if matches, returns result_x. If not, returns default, or, if default is left out, return null . </td>
    </tr>
    <tr>
      <td>TRANSFORM(expression [, formatcodes])</td>
      <td>expression  specifies the character, currency, date, or numeric expression to format.<br>
          formatcode  specifies one format code that determine how the expression is formatted.
          The following table lists the available format codes<br>
          <table>
           <tr><td><b>Format Code</b></td><td><b>Description</b></td>
           <tr>
             <td>@C</td><td>CR is appended to positive currency or numeric values to indicate a credit.</td>
           </tr>
           <tr>
             <td>@D</td><td>act as 	DTOS function.</td>
           </tr>
           <tr>
             <td>@E</td><td>act as 	DTOS function.</td>
           </tr>
           <tr>
             <td>@T</td><td>leading and trailing spaces are trimmed from character values.</td>
           </tr>
           <tr>
             <td>@X</td><td>db is appended to negative currency or numeric values to indicate a debit.</td>
           </tr>
           <tr>
             <td>@Z</td><td>if 0, currency or numeric values are converted to spaces.</td>
           </tr>
           <tr>
             <td>@(</td><td>encloses negative currency or numeric values in parentheses.</td>
           </tr>
           <tr>
             <td>@^</td><td>converts currency or numeric values to scientific notation.</td>
           </tr>
           <tr>
             <td>@0</td><td>converts numeric or currency values to their hexadecimal equivalents.
                  The numeric or currency value must be positive and less than 4,294,967,296.</td>
           </tr>
           <tr>
             <td>!</td><td>	converts a character to uppercase.</td>
           </tr>
           <tr>
             <td>$</td><td>adds the current currency symbol specified by SET CURRENCY to currency and numeric values. By default, the symbol is placed immediately before or after the value. However, the currency symbol and its placement (specified with SET CURRENCY), the separator character (specified with SET SEPARATOR) and the decimal character (specified with SET POINT) can all be changed.</td>
           </tr>
           <tr>
             <td>X</td><td>specifies the width of character values. For example, if cFormatCodes is XX? 2 characters are returned.</td>
           </tr>
           <tr>
             <td>Y</td><td>converts logical true (.T.) and false (.F.) values to Y and N, respectively.</td>
           </tr>
           <tr>
             <td>@!</td><td>converts a string to uppercase.</td>
           </tr>
         </table>
         </td>
         <td>
            return the formatted string</td>
          <td>returns a character string from an expression in a format determined by a format code</td>
         </tr>

      </td>
      <td>
      </td>
      <td>
      </td>
    </tr>
  </table>
</blockquote>
<ol>
    <li>LASTNVL(column): returns the current value for a particuar column. When a null value is encountered,  it will try to return the nearest non-null value of prior rows in the specified table. That function is useful when data are stored by using suppression of repeated data.</li>
    <li>LASTEVL(column): returns the current value for a particuar column. When an empty value is encountered,  it will try to return the nearest non-empty value of prior rows in the specified table. That function is useful when data are stored by using suppression of repeated data. It means empty value when it is a null value, or a string is empty string, spaces, tabs, carriage returns, linefeeds, or any combination of these, numeric value equals to 0, and logical expression is false.</li>
  </ol>
</ol>
<p><A name=aggregate>Aggregate Functions</a></p>
<ol>
  <ol>
    <li>FIRST(expression): the value of a specified field in the first record, respectively,
            of the result set returned by a query.
            Because records are usually returned in no particular order
            (unless the query includes an ORDER BY clause),
            the records returned by this functions will be arbitrary.</li>
    <li>LAST(expression): the value of a specified field in the last record, respectively,
            of the result set returned by a query.
            Because records are usually returned in no particular order
            (unless the query includes an ORDER BY clause),
            the records returned by this functions will be arbitrary.</li>
    <li>AVG(expression): the average (arithmetic mean) of all input values.</li>
    <li>AVG(DISTINCT expression): the average (arithmetic mean) of the distinct values of expression.</li>
    <li>COUNT(*): the number of input values.</li>
    <li>COUNT(expression): the number of input values for which the value of expression
      is not null.</li>
    <li>COUNT(DISTINCT expression): the number of different non-NULL values.</li>
    <li>MAX(expression): the maximum value of expression across all input values.
    </li>
    <li>MIN(expression): the minimum value of expression across all input values.
    </li>
    <li>STD(expression): the sample standard deviation of the input values.</li>
    <li>STDDEV(expression): the sample standard deviation of the input values.</li>
    <li>SUM(expression): the sum of expression across all input values.</li>
    <li>SUM(DISTINCT expression): the sum of the distinct values of expression.</li>
    <li>GROUP_CONCAT([DISTINCT] expr_list [order_by_clause] [SEPARATOR str_val]): returns a string result with the concatenated non-NULL values from a group. It returns NULL if there are no non-NULL values. SEPARATOR is followed by the string value that should be inserted between values of result. The default is a comma (','). You can eliminate the separator altogether by specifying SEPARATOR ''. The result will be truncated to the maximum length of 8192 sometimes.</li>
    <li>GROUPING(expression): returns a value of 1 when the expression is added by either the CUBE or ROLLUP operator, or 0 when the expression is not the result of CUBE or ROLLUP. It is used to distinguish the null values that are returned by CUBE and ROLLUP from standard null values. The NULL returned as the result of a CUBE or ROLLUP operation is a special use of NULL.</li>  
  </ol>
  <p>&nbsp;</p>
</ol>
<div align="center"><font color="#A042FF">Copyright &copy; 1999-2011 Hongxin Technology & Trade Ltd. | All Rights Reserved. |</font> </div></body></html>